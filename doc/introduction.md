MM Language 入門
================

はじめに
--------

ループ演算子、ビームサーチの2つが目玉機能となります。
（バインドとメモ化もかなり強力ではありますが…）

あとはPythonにかなり似ているので、説明をかなり省いています。
説明不足箇所は、比較的沢山用意しているexamplesを参考にしてください。

ループ演算子は使いこなすと柔軟性が高く、ループを多く書く競技プログラミングで非常に短く書くことが出来ます。
この言語特有のビームサーチの書き方は、ビームサーチ系問題へのアプローチを劇的に変えると製作者は思っています。

Hello World
-----------

MM Languageは、Pythonにとても良く似た言語です。

    print("Hello, world!")

というコードを書くだけで、 `Hello, world!` と画面上に表示するプログラムを書けます。

MM Languageでは、拡張子は `.m2` を使用します。
前述のコードを、hello.m2として保存しましょう。

mmコマンドを使って、hello.m2をコンパイルします。

    mm hello.m2

すると、標準出力へと変換されたコードが表示されます。長いライブラリ埋め込みの後に、次の4行が見えるはずです。

    int main() {
        print("Hello, world!");
        return 0;
    }

3つの数の和を求める問題
-----------------------

    A[:3] = inputInt()
    sum = 0
    sum += A[:3]
    print(sum)

と書いた.m2ファイルを作ってコンパイルしてみましょう。
`--run` オプションを付けて実行し、 `1 2 3` と入力し改行すると、 `6` と表示されます。
3つの入力の数の和を求めることに成功していることが分かります。

`--run` オプションを外してみると、以下のようなコードが生成されているのに気付くことができます。

    vector<int> A;
    int sum;
    
    〜中略〜
    
        {
            A.resize(max((int)A.size(), (int)3));
            for(int $1=0, $e=(0<=3 ? 3 : (int)A.size()+3); $1<$e; ++$1) A[$1] = inputInt();
        }
        sum = 0;
        for(int $1=0, $e=(0<=3 ? 3 : (int)A.size()+3); $1<$e; ++$1) sum += A[$1];
        print(sum);

どういう仕組みになっているのでしょうか？

まず、変数が型推論され自動的に定義されていることに気付くと思います。
sumはint型で、Aはintのコンテナという具合です。

また、途中でAに対して自動的にresizeが行われていることに気付くと思います。

Pythonでは、 `A[:3]` という書き方はスライスでしたね。
実は、MM Languageには、スライスは存在しません。
では、これは何なのでしょうか？

MM Languageの作者は、ここに出てくる `:3` のことを、ループ演算子と呼んでいます。

ループ演算子は別に `[]` の中じゃなくても使えます。

ループ演算子
------------

試しに以下のコードを書いて、 `--run` オプション付きで動かしてみましょう。

    print(:3)

なんと表示されましたか？

    0
    1
    2

と表示されたと思います。
`--run` オプションを外してコードを見てみると、

    for(int $1=0, $e=3; $1<$e; ++$1) print($1);

というコードが生成されています。

競技プログラミングだと

    rep(i, 3) print(i)

の様に書くところが、

    print(:3)

で代替されます。

    1
    2
    3

という表示をお望みなのであれば、

    print(1:4)

とすることが可能です。

では、以下の様に書いたら、どうなるでしょうか？

    print(1:3, (1:3)+3)

答えは以下です。

    1 4
    1 5
    2 4
    2 5

`--run` を省いてコードを見ると、以下の様な二重ループになっていることが分かります。

    for(int $1=1, $e=3; $1<$e; ++$1) for(int $2=1, $e=3; $2<$e; ++$2) print($1, ($2) + 3);

予想していたのと違いますか？　実はループ演算子によって生成されたループ変数は、参照することが可能です。
順に `$1` , `$2` , `$3` , ... と名前が付きます。

すなわち、以下の様なコードが書けます。

    print(1:4, $1*$1)

動かすと以下の様になります。

    1 1
    2 4
    3 9

……え？　変な名前のループ変数は嫌ですか？　では自由に名前を付けましょう。

    print(i@1:4, i*i)

同じ結果が得られます。

ちなみに `@` はバインドであり、ループ演算子とは無関係です。
試しに以下の様なコードを書いてみましょうか。

    print(i@1:4, j@i*i, j*j)

以下の様な結果が得られます。

    1 1 1
    2 4 16
    3 9 81

バインドはそのステートメント内でのみ有効です。順番は関係なくバインドした名前を使うことが可能なので、以下の様なコードでも動きます。

    print(i@1:4, j*j, j@i*i)

以下の様な実行結果になります。

    1 1 1
    2 16 4
    3 81 9

`--run` を省いて、生成されたコードを見てみましょう。

        for(int i=1, $e=4; i<$e; ++i) {
            const auto & j = i * i;
            print(i, j * j, j);
        }

i*iは一度しか計算されていないことが分かると思います。
2回以上実行されてしまう様な副作用の発生する仕組みになっていないため、関数呼び出し結果の戻り値なども安心してバインド可能です。

ループ演算子と型指定
--------------------

    a:char = 66
    print(a)

紛らわしい言語仕様になっていて申し訳ありません。

`:` 記号はほとんどの場合にループ演算子として機能しますが、3つのパターンでのみ型指定として機能します。

1つ目は、関数定義時の引数名の直後に発生した場合。

2つ目は、代入文の代入先（=が複数連なっている場合には、最右辺以外の全て）に、それだけが書かれている場合。

3つ目は、ステートメントとしてそれだけが書かれている場合……つまり、以下の様な場合です。

    a:char

言語内部では、2つ目と3つ目は同じ扱いをされています。
3つ目のパターンでは、a〜char間でfor文を回したとしても、ループ内の処理が何も無いことが保証される書き方になるので、2つ目のパターンに準じることができるという道理です。

しかしながら、もしも `a:char` と書かれているのが代入文の最右辺だった場合はどうでしょうか？　その場合は、for文を回した

なお、以下の場合は、「それだけが書かれている」とはみなされないため、ループ演算子として認識されます。

    (a:char)

代入の場合も、同様に `()` などは使えません。

統計関数
--------

    print(1:4)

上記で下記の実行結果になることは、ループ演算子の説明にて行いました。

    1
    2
    3

では今度は、以下の様なコードを書くと、どうなるでしょうか？

    print(sum(1:4))

結果は以下の様になります。

    6

MM Languageでは、min, max, sum, mean, medianの関数呼び出しが1つだけの引数を取る場合においては、その内部で使われているループ演算子を閉じ込めて統計処理を行います。

関数とメモ化
------------

メモ化の練習のために、フィボナッチ数列の45番目を求めてみましょう。
関数はPythonでの書き方とほぼ同じです。ただし、戻り値の型は明確に指定する必要があります。

    def fibonacci(i) -> int:
        if i==0:
            return 0
        if i==1:
            return 1
        return fibonacci(i-1) + fibonacci(i-2)
    print(fibonacci(45))
    print("time:", getTime())

実行すると以下の様な結果が得られます。

    1134903170
    time: 4.45843

時間の測定にMM Languageの標準関数として用意されている（リポジトリ内のlibフォルダ）、実行開始からの秒数をdouble型で返してくれるgetTime関数を用いています。
getTime関数はヒューリスティックコンテストで頻繁に呼ぶために用意されているため、厳密な時間を返してくれないことがありますが、アルゴリズムやヒューリスティックのコンテスト用途では通常問題ない働きをしてくれます。

4.45秒もかかって重たいですね……メモ化してみましょう。

    @memo
    def fibonacci(i) -> int:
        if i==0:
            return 0
        if i==1:
            return 1
        return fibonacci(i-1) + fibonacci(i-2)
    print(fibonacci(45))
    print("time:", getTime())

メモ化できました。1行目に `@memo` とデコレータが付け足されただけですね。でも実行してみると、その効果が分かります。

    1134903170
    time: 4.852e-05

……メモ化出来ています。

実はこのメモ化の方法は内部で `std::map` を使っているため、少し低速です。
`std::map` ではなく `std::vector` を使ってメモ化したい場合は、デコレータ引数に付け足す形で次の様に書きます。

    @memo(size=200)
    def fibonacci(i) -> int:
        if i==0:
            return 0
        if i==1:
            return 1
        return fibonacci(i-1) + fibonacci(i-2)

    print(fibonacci(45))
    print("time:", getTime())

引数が複数ある場合は、 `size=(200, 300)` の様な書き方になります。

なお、問題によっては再帰呼び出しが閉路になっている可能性があり、それを検出したい場合が存在します。
そういうときは、 `cycle=-1` の様な指定が可能です。
閉路が検出された際には、指定した戻り値が戻る様になります。
`cycle` の指定が無いときに閉路に出会うと、無限ループに陥ります。（スタックを食いつぶして止まるかもしれません）

また、 `@memo` には `default` の指定が可能です。これは `size` の指定が行われて `std::vector` でメモが管理されている際に有効です。
メモは `vector` で管理されているため、何らかの値を持ちます。まだメモしていないことを示す値というものが存在します。
`default` の指定がまずい場合、計算結果は間違いませんが、何度も再計算することになります。
現在の実装では `default` を指定しない場合、 `-2147483648` を使うことになりますので、通常は問題ないと思います。
`default` なんていうものが存在することは、忘れてしまって差し支えないかもしれません。

ビームサーチ
------------

MM Languageでは、 `@memo` の延長線上のアイデアで、ビームサーチを短く書くことに成功しています。
しかもとても高速に動作します。

少しだけ覚えることが多いですが、 Chokudai Contest 005 の1位と僅差のパフォーマンスを出すコードが49行で書けてしまいます。

https://atcoder.jp/contests/chokudai005/submissions/20236871

色々と複雑なので、エッセンスだけを説明します。

`xarray` や `xvector` の様な接頭辞 `x` が付く一部の型は、メモリ状態が自動管理されます。
（MM Languageにて使われているビームサーチライブラリは、元々外部ビームサーチと呼ばれていました。外部を示すexternalの略でexの接頭辞を当初は使っていましたが、exは英語圏ではエックスと読みますので、xの1文字だけにしました）

`@memo` と同様に `@beam` を使うと、ビームサーチ化することができます。

ビームサーチ化された関数内では、メモリ自動管理型の変数は、状態を書き換えても自動的に関数から戻る際にundoされます。

ビームサーチ化した関数では、最初に引数を元に状態を書き換え、そのあとに再帰呼び出しを行うコードを書くことになります。
通常の再帰呼び出し探索プログラムでは、undo処理も書く必要がありますが、MM Languageのビームサーチ特化の書き方では、undo処理は書いてはいけません。

書き換えた内容が自動抽出され、そのundo/redoを効果的に使いながら探索木をビームサーチ探索してくれます。
また、時間管理なども比較的効率的に行ってくれます。

再帰呼び出ししている様に書いていますが、内部的には実際には再帰呼出しせずに、ビームへの予約を行っているため、再帰呼び出ししたはずのものが実際は実行されないこともありますので、その辺りは慣れて分かっていくのが良いと思います。

なお、ビームサーチ化された関数に `score` という名前の引数が存在する場合は、score値が高いものの探索を目指してくれます。
また、ビームサーチ化された関数に `hash` という名前の引数が存在する場合は、hash値が重複する再帰呼び出しの探索は見送ります。
（ビームサーチの重複除去は、メモ化の様な効果があります）

なお、 `examples/chokudai005b.m2` では、MM Languageでのビームサーチ化があまりに手軽に出来てしまうため、ビームサーチ内の評価関数で、別のビームサーチを探索した結果を評価値として使う様なことをしています。
コードはビームサーチ部分をほとんど丸々複製しているため、85行と長くはなっていますが、ほとんど手間がかからずにChokudai Contest 005 の1位を抜くことに成功しています。

焼きなましや、山登り+kickの評価関数に、ビームサーチが使える可能性も、少しあるかもしれません。（たとえばTSPに対して、20optのLKHもどきをビームサーチで…など）

プロファイラ
------------

mmコマンド呼び出し時のオプションで `--profiler` を指定することで、プロファイラを埋め込むことが可能です。
プロファイラは実行終了時に、MM Language時点の各行番号ごとの計算時間割合を表示してくれます。

AtCoder Tools対応機能について
-----------------------------

`python3 -m pip install atcoder-tools` などで、AtCoder Toolsをインストール済みである必要があります。

### コード生成

mmコマンド呼び出し時のオプションで `--ac-gen` を指定することで、入力周りのソースコード自動生成が可能です。

SOURCEが拡張子なしの場合は、SOURCEの最後の `/` 以降をコンテストIDとみなし、そのコンテストの全ての問題の `.m2` ファイルを生成します。

SOURCEが拡張子 `.m2` で、ファイル名の拡張子を除いた部分に `_` が1つだけ含まれる場合は、 `_` 以前をコンテストIDとみなし、 `_` 以降を問題IDの接尾辞とみなして、 `.m2` ファイルを生成します。このときに、直接的に問題IDとみなすわけではないことに注意してください。

### コードテスト

mmコマンド呼び出し時のオプションで `--ac-test` を指定することで、AtCoder Toolsを使ってのテストが可能となります。
`--ac-gen` コマンドで生成されたファイルは以下のコメント行を持ちますので、ここでどのAtCoder問題であるかを指定していることになります。

    # atcoder: abc001_1 ( https://abc001.contest.atcoder.jp/tasks/abc001_1 )

なお、以下のどちらでも動きます。

URL指定…

    # atcoder: https://abc001.contest.atcoder.jp/tasks/abc001_1

非URL指定…

    # atcoder: abc001_1

URL指定時の `tasks/` 以下が問題IDであるのに対して、URLを用いずに指定した際には、コンテストID + `_` + (問題IDの接尾辞) とみなされることに再度注意して下さい。

### コードサブミット

mmコマンド呼び出し時のオプションで `--ac-submit` を指定することで、テスト成功時に AtCoder Tools を用いてコンテストへの送信を行う様になります。

既に送信済みの問題に対して送信をする際には `--ac-submit2` を指定する必要があります。（安全機能）

また、SOURCEがフォルダの際には、 `--ac-submit-folder` を指定する必要があります。（安全機能）

なお、フォルダまるごと送信機能を実装はしていますが、ratedに対しての送信なし不参加扱いを推奨しているわけではありません。
